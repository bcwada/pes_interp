import numpy as np
import os

from dataclasses import dataclass

from pathlib import Path

import lib.tc_reader as tcReader
import lib.xyz as xyz
import lib.context_manager as conman

@dataclass
class trajectory:
    t: float
    x: np.array
    v: np.array
    a: np.array
    m: np.array
    elements: np.array
    t_history: list
    x_history: list
    terachem_input: Path
    sbatch_input: Path
    work_dir: Path
    num_calcs: int
    restart: bool

    @classmethod
    def from_init_conds(cls,x,v,m,elements,tc,sbatch,work_dir):
        dalton2me = 1822.88848620953
        m = dalton2me*np.tile(m,(3,1)).T
        tc = tc.absolute()
        sbatch = sbatch.absolute()
        work_dir = work_dir.absolute()
        return cls(0,x,v,np.zeros_like(v),m,elements,[0],[x],tc,sbatch,work_dir,0,False)

    def set_restart(self, boolean):
        self.restart = boolean

    def step(self, timestep):
        # shape of grad should match that of x,v and a
        v_halfstep = self.v + timestep*self.a/2
        self.x = self.x + timestep*v_halfstep
        self.a = -(1/self.m)*self.get_grad()
        self.v = v_halfstep + timestep*self.a/2

        self.t += timestep
        self.t_history.append(self.t)
        self.x_history.append(self.x)

    def get_grad(self):
        # launch terachem job
        self.num_calcs += 1
        job = f"{self.num_calcs:06d}"
        geom = xyz.Geometry(len(self.elements),"generated by grow_vv",self.elements,self.x)
        try:
            with conman.minimal_context(self.work_dir/job,self.terachem_input,self.sbatch_input) as man:
                print("launching job")
                print(os.getcwd())
                geom.write_file("geom.xyz")
                man.launch()
                man.wait_for_job()
                output = tcReader.gradient.from_file("tc.out")
        except conman.DirNotEmpty:
            if self.restart:
                print("loading existing data")
                with conman.enter_dir(self.work_dir/job):
                    output = tcReader.gradient.from_file("tc.out")
        return output.grad

    def write_out_geometries(self,file):
        geoms = []
        for i in range(len(self.t_history)):
            geoms.append(xyz.Geometry(len(self.elements),f"t={self.t_history[i]}; ES/PES interp",self.elements,self.x_history[i]))
        geoms = xyz.combinedGeoms(geoms)
        geoms.write_all(file)


