import numpy as np
import os
import shutil
from dataclasses import dataclass
from contextlib import contextmanager
from pathlib import Path

import tools.constants as constants
import tools.tcReader as tcReader
import tools.xyz as xyz
from tools.fireContext import SbatchManager
from tools.fireContext import enter_existing_space

class DirNotEmpty(Exception):
    pass

@dataclass
class trajectory:
    t: float
    x: np.array
    v: np.array
    a: np.array
    m: np.array
    elements: np.array
    t_history: list
    x_history: list
    terachem_input: Path
    sbatch_input: Path
    work_dir: Path
    num_calcs: int
    restart: bool

    @classmethod
    def from_init_conds(cls,x,v,m,elements,tc,sbatch,work_dir):
        m = constants.dalton2me*np.tile(m,(3,1)).T
        tc = tc.absolute()
        sbatch = sbatch.absolute()
        work_dir = work_dir.absolute()
        return cls(0,x,v,np.zeros_like(v),m,elements,[0],[x],tc,sbatch,work_dir,0,False)

    def set_restart(self, boolean):
        self.restart = boolean

    def step(self, timestep):
        # shape of grad should match that of x,v and a
        v_halfstep = self.v + timestep*self.a/2
        self.x = self.x + timestep*v_halfstep
        self.a = -(1/self.m)*self.get_grad()
        self.v = v_halfstep + timestep*self.a/2

        self.t += timestep
        self.t_history.append(self.t)
        self.x_history.append(self.x)

    def get_grad(self):
        # launch terachem job
        self.num_calcs += 1
        job = f"{self.num_calcs:06d}"
        geom = xyz.Geometry(len(self.elements),"generated by grow_vv",self.elements,self.x)
        try:
            with minimal_context(self.work_dir/job,self.terachem_input,self.sbatch_input) as man:
                print("launching job")
                print(os.getcwd())
                geom.write_file("geom.xyz")
                man.launch()
                man.wait_for_job()
                output = tcReader.gradient.from_file("tc.out")
        except DirNotEmpty:
            if self.restart:
                print("loading existing data")
                with enter_existing_space(self.work_dir/job):
                    output = tcReader.gradient.from_file("tc.out")
        return output.grad

    def write_out_geometries(self,file):
        geoms = []
        for i in range(len(self.t_history)):
            geoms.append(xyz.Geometry(len(self.elements),f"t={self.t_history[i]}; ES/PES interp",self.elements,self.x_history[i]))
        geoms = xyz.combinedGeoms(geoms)
        geoms.write_all(file)

@contextmanager
def minimal_context(newDir, tc_input, sbatch_input):
    origDir = os.getcwd()
    print(newDir)
    if newDir.exists():
        raise DirNotEmpty
    else:
        newDir.mkdir(parents=True)
    try:
        os.chdir(os.path.expanduser(newDir))
        shutil.copy(tc_input, newDir)
        shutil.copy(sbatch_input, newDir)
        yield SbatchManager.setup("sbatch.sh")
        #yield RunManager.create_manager(tc_file_name, sbatch_file_name, extra_files, debug)
    finally:
        os.chdir(origDir)
